/* Auto-generated by genmsg_cpp for file /home/travis/ros_workspace/NNTracker/msg/NNTrackerROI.msg */
#ifndef NNTRACKER_MESSAGE_NNTRACKERROI_H
#define NNTRACKER_MESSAGE_NNTRACKERROI_H
#include <string>
#include <vector>
#include <map>
#include <ostream>
#include "ros/serialization.h"
#include "ros/builtin_message_traits.h"
#include "ros/message_operations.h"
#include "ros/time.h"

#include "ros/macros.h"

#include "ros/assert.h"


namespace NNTracker
{
template <class ContainerAllocator>
struct NNTrackerROI_ {
  typedef NNTrackerROI_<ContainerAllocator> Type;

  NNTrackerROI_()
  : ulx(0.0)
  , uly(0.0)
  , urx(0.0)
  , ury(0.0)
  , lrx(0.0)
  , lry(0.0)
  , llx(0.0)
  , lly(0.0)
  , area(0.0)
  , perimeter(0.0)
  , cmx(0.0)
  , cmy(0.0)
  {
  }

  NNTrackerROI_(const ContainerAllocator& _alloc)
  : ulx(0.0)
  , uly(0.0)
  , urx(0.0)
  , ury(0.0)
  , lrx(0.0)
  , lry(0.0)
  , llx(0.0)
  , lly(0.0)
  , area(0.0)
  , perimeter(0.0)
  , cmx(0.0)
  , cmy(0.0)
  {
  }

  typedef float _ulx_type;
  float ulx;

  typedef float _uly_type;
  float uly;

  typedef float _urx_type;
  float urx;

  typedef float _ury_type;
  float ury;

  typedef float _lrx_type;
  float lrx;

  typedef float _lry_type;
  float lry;

  typedef float _llx_type;
  float llx;

  typedef float _lly_type;
  float lly;

  typedef float _area_type;
  float area;

  typedef float _perimeter_type;
  float perimeter;

  typedef float _cmx_type;
  float cmx;

  typedef float _cmy_type;
  float cmy;


  typedef boost::shared_ptr< ::NNTracker::NNTrackerROI_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::NNTracker::NNTrackerROI_<ContainerAllocator>  const> ConstPtr;
  boost::shared_ptr<std::map<std::string, std::string> > __connection_header;
}; // struct NNTrackerROI
typedef  ::NNTracker::NNTrackerROI_<std::allocator<void> > NNTrackerROI;

typedef boost::shared_ptr< ::NNTracker::NNTrackerROI> NNTrackerROIPtr;
typedef boost::shared_ptr< ::NNTracker::NNTrackerROI const> NNTrackerROIConstPtr;


template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const  ::NNTracker::NNTrackerROI_<ContainerAllocator> & v)
{
  ros::message_operations::Printer< ::NNTracker::NNTrackerROI_<ContainerAllocator> >::stream(s, "", v);
  return s;}

} // namespace NNTracker

namespace ros
{
namespace message_traits
{
template<class ContainerAllocator> struct IsMessage< ::NNTracker::NNTrackerROI_<ContainerAllocator> > : public TrueType {};
template<class ContainerAllocator> struct IsMessage< ::NNTracker::NNTrackerROI_<ContainerAllocator>  const> : public TrueType {};
template<class ContainerAllocator>
struct MD5Sum< ::NNTracker::NNTrackerROI_<ContainerAllocator> > {
  static const char* value() 
  {
    return "5f0574d8c71c1b4e4f70c00dc6bc1394";
  }

  static const char* value(const  ::NNTracker::NNTrackerROI_<ContainerAllocator> &) { return value(); } 
  static const uint64_t static_value1 = 0x5f0574d8c71c1b4eULL;
  static const uint64_t static_value2 = 0x4f70c00dc6bc1394ULL;
};

template<class ContainerAllocator>
struct DataType< ::NNTracker::NNTrackerROI_<ContainerAllocator> > {
  static const char* value() 
  {
    return "NNTracker/NNTrackerROI";
  }

  static const char* value(const  ::NNTracker::NNTrackerROI_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator>
struct Definition< ::NNTracker::NNTrackerROI_<ContainerAllocator> > {
  static const char* value() 
  {
    return "# Description of a warped rectangular region\n\
\n\
float32 ulx\n\
float32 uly\n\
\n\
float32 urx\n\
float32 ury\n\
\n\
float32 lrx\n\
float32 lry\n\
\n\
float32 llx\n\
float32 lly\n\
\n\
float32 area\n\
\n\
float32 perimeter\n\
\n\
float32 cmx\n\
float32 cmy\n\
\n\
\n\
\n\
";
  }

  static const char* value(const  ::NNTracker::NNTrackerROI_<ContainerAllocator> &) { return value(); } 
};

template<class ContainerAllocator> struct IsFixedSize< ::NNTracker::NNTrackerROI_<ContainerAllocator> > : public TrueType {};
} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

template<class ContainerAllocator> struct Serializer< ::NNTracker::NNTrackerROI_<ContainerAllocator> >
{
  template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
  {
    stream.next(m.ulx);
    stream.next(m.uly);
    stream.next(m.urx);
    stream.next(m.ury);
    stream.next(m.lrx);
    stream.next(m.lry);
    stream.next(m.llx);
    stream.next(m.lly);
    stream.next(m.area);
    stream.next(m.perimeter);
    stream.next(m.cmx);
    stream.next(m.cmy);
  }

  ROS_DECLARE_ALLINONE_SERIALIZER;
}; // struct NNTrackerROI_
} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::NNTracker::NNTrackerROI_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const  ::NNTracker::NNTrackerROI_<ContainerAllocator> & v) 
  {
    s << indent << "ulx: ";
    Printer<float>::stream(s, indent + "  ", v.ulx);
    s << indent << "uly: ";
    Printer<float>::stream(s, indent + "  ", v.uly);
    s << indent << "urx: ";
    Printer<float>::stream(s, indent + "  ", v.urx);
    s << indent << "ury: ";
    Printer<float>::stream(s, indent + "  ", v.ury);
    s << indent << "lrx: ";
    Printer<float>::stream(s, indent + "  ", v.lrx);
    s << indent << "lry: ";
    Printer<float>::stream(s, indent + "  ", v.lry);
    s << indent << "llx: ";
    Printer<float>::stream(s, indent + "  ", v.llx);
    s << indent << "lly: ";
    Printer<float>::stream(s, indent + "  ", v.lly);
    s << indent << "area: ";
    Printer<float>::stream(s, indent + "  ", v.area);
    s << indent << "perimeter: ";
    Printer<float>::stream(s, indent + "  ", v.perimeter);
    s << indent << "cmx: ";
    Printer<float>::stream(s, indent + "  ", v.cmx);
    s << indent << "cmy: ";
    Printer<float>::stream(s, indent + "  ", v.cmy);
  }
};


} // namespace message_operations
} // namespace ros

#endif // NNTRACKER_MESSAGE_NNTRACKERROI_H

